"use strict";(self.webpackChunkpsychic_guides=self.webpackChunkpsychic_guides||[]).push([[4519],{4184:(e,o,n)=>{n.r(o),n.d(o,{assets:()=>a,contentTitle:()=>i,default:()=>l,frontMatter:()=>r,metadata:()=>t,toc:()=>c});var s=n(4848),d=n(8453);const r={},i="order",t={id:"models/associations/options/order",title:"order",description:"When an association is defined with an order, that ordering is automatically applied whenever loading or preloading models. Association order supports the same options as query order.",source:"@site/docs/models/associations/options/order.mdx",sourceDirName:"models/associations/options",slug:"/models/associations/options/order",permalink:"/docs/models/associations/options/order",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/models/associations/options/order.mdx",tags:[],version:"current",frontMatter:{},sidebar:"guides",previous:{title:"optional",permalink:"/docs/models/associations/options/optional"},next:{title:"polymorphic",permalink:"/docs/models/associations/options/polymorphic"}},a={},c=[];function p(e){const o={a:"a",code:"code",h1:"h1",p:"p",pre:"pre",...(0,d.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(o.h1,{id:"order",children:"order"}),"\n",(0,s.jsxs)(o.p,{children:["When an association is defined with an ",(0,s.jsx)(o.code,{children:"order"}),", that ordering is automatically applied whenever ",(0,s.jsx)(o.code,{children:"loading"})," or ",(0,s.jsx)(o.a,{href:"../../querying/preload",children:(0,s.jsx)(o.code,{children:"preloading"})})," models. Association ",(0,s.jsx)(o.code,{children:"order"})," supports the same options as query ",(0,s.jsx)(o.a,{href:"../../querying/order",children:(0,s.jsx)(o.code,{children:"order"})}),"."]}),"\n",(0,s.jsx)(o.pre,{children:(0,s.jsx)(o.code,{className:"language-typescript",children:"export default class GraphNode extends ApplicationModel {\n  // ...\n\n  public name: string\n\n  ///////////////////////////////////////////\n  // order built into the join association //\n  ///////////////////////////////////////////\n  @HasMany(() => EdgeNode, { foreignKey: 'nodeId', order: 'position' })\n  public orderedEdgeNodes: EdgeNode[]\n\n  @HasMany(() => GraphEdge, { through: 'orderedEdgeNodes' })\n  public edges: GraphEdge[]\n\n  //////////////////////////////////////////////\n  // order applied to the through association //\n  //////////////////////////////////////////////\n  @HasMany(() => EdgeNode, { foreignKey: 'nodeId' })\n  public edgeNodes: EdgeNode[]\n\n  @HasMany(() => GraphEdge, {\n    through: 'edgeNodes',\n    order: 'weight',\n    source: 'edge', // since `edgesOrderedByWeight` does not correspond to an\n    // association on EdgeNode, we explicitly specify the EdgeNode association\n    // to use as the source of the models to instantiate\n  })\n  public edgesOrderedByWeight: GraphEdge[]\n}\n\nexport default class EdgeNode extends ApplicationModel {\n  // ...\n\n  @Sortable({ scope: 'node' })\n  public position: DreamColumn<EdgeNode, 'position'>\n\n  @BelongsTo(() => GraphEdge, { foreignKey: 'edgeId' })\n  public edge: GraphEdge\n  public edgeId: DreamColumn<EdgeNode, 'edgeId'>\n\n  @BelongsTo(() => GraphNode, { foreignKey: 'nodeId' })\n  public node: GraphNode\n  public nodeId: DreamColumn<EdgeNode, 'nodeId'>\n}\n\nexport default class GraphEdge extends ApplicationModel {\n  // ...\n  public weight: DreamColumn<GraphEdge, 'weight'>\n}\n"})})]})}function l(e={}){const{wrapper:o}={...(0,d.R)(),...e.components};return o?(0,s.jsx)(o,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},8453:(e,o,n)=>{n.d(o,{R:()=>i,x:()=>t});var s=n(6540);const d={},r=s.createContext(d);function i(e){const o=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function t(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:i(e.components),s.createElement(r.Provider,{value:o},e.children)}}}]);