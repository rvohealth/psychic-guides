"use strict";(self.webpackChunkpsychic_guides=self.webpackChunkpsychic_guides||[]).push([[391],{8112:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>l});var r=t(4848),s=t(8453);const a={sidebar_position:7},o="hooks",i={id:"models/hooks",title:"hooks",description:"before create",source:"@site/docs/models/hooks.mdx",sourceDirName:"models",slug:"/models/hooks",permalink:"/docs/models/hooks",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/models/hooks.mdx",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"guides",previous:{title:"single table inheritance",permalink:"/docs/models/single-table-inheritance"},next:{title:"scopes",permalink:"/docs/models/scopes"}},d={},l=[{value:"before create",id:"before-create",level:2},{value:"before update",id:"before-update",level:2},{value:"before save",id:"before-save",level:2},{value:"before destroy",id:"before-destroy",level:2},{value:"after create",id:"after-create",level:2},{value:"after update",id:"after-update",level:2},{value:"after save",id:"after-save",level:2},{value:"after destroy",id:"after-destroy",level:2},{value:"commit hooks",id:"commit-hooks",level:2},{value:"after create commit",id:"after-create-commit",level:3},{value:"after update commit",id:"after-update-commit",level:3},{value:"after save commit",id:"after-save-commit",level:3},{value:"after destroy commit",id:"after-destroy-commit",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"hooks",children:"hooks"}),"\n",(0,r.jsx)(n.h2,{id:"before-create",children:"before create"}),"\n",(0,r.jsx)(n.p,{children:"BeforeCreate hooks are run whenever a new record is being saved to the database. A decorator pattern is leveraged, so no arguments need to be passed to the hook, it simply needs to live above the property, like so:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export default class User extends Dream {\n  @BeforeCreate()\n  public async hashPassword() {\n    if (this.password) this.passwordDigest = await Hash.gen(this.password)\n    this.password = undefined\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"before-update",children:"before update"}),"\n",(0,r.jsx)(n.p,{children:"BeforeUpdate hooks are run whenever an existing (meanin, previously-saved) record is updated, and can be leveraged like so:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export default class Post extends Dream {\n  public readonly get table() {\n    return 'posts' as const\n  }\n\n  public id: number\n  public content: string | null\n  ...\n\n  @BeforeUpdate()\n  public async doSomething() {\n    // ... do whatever you want here!\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"before-save",children:"before save"}),"\n",(0,r.jsx)(n.p,{children:"BeforeSave hooks are run whenever either an existing OR new record is written to the DB, and can be leveraged like so:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export default class Post extends Dream {\n  public readonly get table() {\n    return 'posts' as const\n  }\n\n  public id: number\n  public content: string | null\n  ...\n\n  @BeforeSave()\n  public async doSomething() {\n    // ... do whatever you want here!\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"before-destroy",children:"before destroy"}),"\n",(0,r.jsx)(n.p,{children:"BeforeDestroy hooks are run whenever either an existing record is destroyed from the DB, and can be leveraged like so:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export default class Post extends Dream {\n  public readonly get table() {\n    return 'posts' as const\n  }\n\n  public id: number\n  public content: string | null\n  ...\n\n  @BeforeDestroy()\n  public async doSomething() {\n    // ... do whatever you want here!\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"after-create",children:"after create"}),"\n",(0,r.jsx)(n.p,{children:"AfterCreate hooks are run after a new record is saved to the database. A decorator pattern is leveraged, so no arguments need to be passed to the hook, it simply needs to live above the property, like so:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export default class Post extends Dream {\n  public readonly get table() {\n    return 'posts' as const\n  }\n\n  public id: number\n  public content: string | null\n  ...\n\n  @AfterCreate()\n  public async hashPassword() {\n    if (this.password)\n      this.password_digest = await Hash.gen(this.password)\n    this.password = undefined\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"after-update",children:"after update"}),"\n",(0,r.jsx)(n.p,{children:"AfterUpdate hooks are run whenever an existing (meanin, previously-saved) record has been updated, and can be leveraged like so:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export default class Post extends Dream {\n  public readonly get table() {\n    return 'posts' as const\n  }\n\n  public id: number\n  public content: string | null\n  ...\n\n  @AfterUpdate()\n  public async doSomething() {\n    // ... do whatever you want here!\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"after-save",children:"after save"}),"\n",(0,r.jsx)(n.p,{children:"AfterSave hooks are run whenever either an existing OR new record has been written to the DB, and can be leveraged like so:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export default class Post extends Dream {\n  public readonly get table() {\n    return 'posts' as const\n  }\n\n  public id: number\n  public content: string | null\n  ...\n\n  @AfterSave()\n  public async doSomething() {\n    // ... do whatever you want here!\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"after-destroy",children:"after destroy"}),"\n",(0,r.jsx)(n.p,{children:"AfterDestroy hooks are run whenever either an existing record has been destroyed from the DB, and can be leveraged like so:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export default class Post extends Dream {\n  public readonly get table() {\n    return 'posts' as const\n  }\n\n  public id: number\n  public content: string | null\n  ...\n\n  @AfterDestroy()\n  public async doSomething() {\n    // ... do whatever you want here!\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"commit-hooks",children:"commit hooks"}),"\n",(0,r.jsx)(n.p,{children:"In contrast to ordinary after hooks (like AfterCreate, AfterUpdate, etc...), we have commit variants. Our implementation is similar to the approach taken by Ruby on Rails, whereby our commit hooks are bound to an existing transaction if it exists, and will wait until after the commit has been made at the transaction level to run your callback."}),"\n",(0,r.jsx)(n.h3,{id:"after-create-commit",children:"after create commit"}),"\n",(0,r.jsx)(n.p,{children:"AfterCreateCommit hooks are run after a new record is saved to the database and the transaction is committed."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export default class Post extends Dream {\n  public readonly get table() {\n    return 'posts' as const\n  }\n\n  public id: number\n  public content: string | null\n  ...\n\n  @AfterCreateCommit()\n  public async yourThing() {\n    // ... your code\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"after-update-commit",children:"after update commit"}),"\n",(0,r.jsx)(n.p,{children:"AfterUpdateCommit hooks are run whenever an existing (meanin, previously-saved) record has been updated and the encapsulating transaction has been committed, and can be leveraged like so:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export default class Post extends Dream {\n  public readonly get table() {\n    return 'posts' as const\n  }\n\n  public id: number\n  public content: string | null\n  ...\n\n  @AfterUpdateCommit()\n  public async doSomething() {\n    // ... do whatever you want here!\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"after-save-commit",children:"after save commit"}),"\n",(0,r.jsx)(n.p,{children:"AfterSaveCommit hooks are run whenever either an existing OR new record has been written to the DB and the encapsulating transaction has been committed, and can be leveraged like so:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export default class Post extends Dream {\n  public readonly get table() {\n    return 'posts' as const\n  }\n\n  public id: number\n  public content: string | null\n  ...\n\n  @AfterSaveCommit()\n  public async doSomething() {\n    // ... do whatever you want here!\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"after-destroy-commit",children:"after destroy commit"}),"\n",(0,r.jsx)(n.p,{children:"AfterDestroyCommit hooks are run whenever an existing record has been destroyed from the DB and the transaction has been committed, and can be leveraged like so:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export default class Post extends Dream {\n  public readonly get table() {\n    return 'posts' as const\n  }\n\n  public id: number\n  public content: string | null\n  ...\n\n  @AfterDestroyCommit()\n  public async doSomething() {\n    // ... do whatever you want here!\n  }\n}\n"})})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var r=t(6540);const s={},a=r.createContext(s);function o(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);