"use strict";(self.webpackChunkpsychic_guides=self.webpackChunkpsychic_guides||[]).push([[4528],{8906:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>c});var t=s(4848),r=s(8453);s(6592);const a={sidebar_position:6},o="authenticating",i={id:"getting-started/authenticating",title:"authenticating",description:"Now that you have a new app built, you are likely pondering next steps, which usually involve building a login and registration flow for your app users. Most applications will require some sort of authentication paradigm to resolve tokens or cookies to users in your database. Since these needs will be radically different from company to company, we do not try to force you to use one or another pattern, but here we will cover one example of how to do this using entirely psychic-driven tools.",source:"@site/docs/getting-started/authenticating.mdx",sourceDirName:"getting-started",slug:"/getting-started/authenticating",permalink:"/docs/getting-started/authenticating",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/getting-started/authenticating.mdx",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"guides",previous:{title:"new app",permalink:"/docs/getting-started/new-app"},next:{title:"client integration",permalink:"/docs/getting-started/client-integration"}},l={},c=[];function d(e){const n={code:"code",h1:"h1",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"authenticating",children:"authenticating"}),"\n",(0,t.jsx)(n.p,{children:"Now that you have a new app built, you are likely pondering next steps, which usually involve building a login and registration flow for your app users. Most applications will require some sort of authentication paradigm to resolve tokens or cookies to users in your database. Since these needs will be radically different from company to company, we do not try to force you to use one or another pattern, but here we will cover one example of how to do this using entirely psychic-driven tools."}),"\n",(0,t.jsx)(n.p,{children:"To quickly accelerate things for us, let's use the resource generator to generate:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"a new controller"}),"\n",(0,t.jsx)(n.li,{children:"a new controller spec"}),"\n",(0,t.jsx)(n.li,{children:"a new model"}),"\n",(0,t.jsx)(n.li,{children:"a new model spec"}),"\n",(0,t.jsx)(n.li,{children:"a new factory"}),"\n",(0,t.jsx)(n.li,{children:"a new migration"}),"\n",(0,t.jsx)(n.li,{children:"a new serializer"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"$ yarn psy g:resource api/v1/users User email:string password_digest:string role:enum:user_role:App,Admin\n"})}),"\n",(0,t.jsx)(n.p,{children:"This will generate the following:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["A new ",(0,t.jsx)(n.code,{children:"User"})," model"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"import { DreamColumn } from '@rvohealth/dream'\nimport ApplicationModel from './ApplicationModel'\nimport UserSerializer, {\n  UserSummarySerializer,\n} from '../../../src/app/serializers/UserSerializer'\n\nexport default class User extends ApplicationModel {\n  public get table() {\n    return 'users' as const\n  }\n\n  public get serializers() {\n    return {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      default: UserSerializer<any, any>,\n\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      summary: UserSummarySerializer<any, any>,\n    } as const\n  }\n\n  public id: DreamColumn<User, 'id'>\n  public email: DreamColumn<User, 'email'>\n  public passwordDigest: DreamColumn<User, 'passwordDigest'>\n  public userRole: DreamColumn<User, 'userRole'>\n  public createdAt: DreamColumn<User, 'createdAt'>\n  public updatedAt: DreamColumn<User, 'updatedAt'>\n}\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsxs)(n.li,{children:["a ",(0,t.jsx)(n.code,{children:"UsersController"})]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"import AuthedController from '../../AuthedController'\nimport User from '../../../models/User'\n\nexport default class ApiV1UsersController extends AuthedController {\n  public async create() {\n    //    const user = await this.currentUser.createAssociation('users', this.paramsFor(User))\n    //    this.created(user)\n  }\n\n  public async index() {\n    //    const users = await this.currentUser.associationQuery('users').all()\n    //    this.ok(users)\n  }\n\n  public async show() {\n    //    const user = await this.currentUser.associationQuery('users').find(this.castParam('id', 'string'))\n    //    this.ok(user)\n  }\n\n  public async update() {\n    //    const user = await this.currentUser.associationQuery('users').find(this.castParam('id', 'string'))\n    //    await user.update(this.paramsFor(User))\n    //    this.noContent()\n  }\n\n  public async destroy() {\n    //    const user = await this.currentUser.associationQuery('users').find(this.castParam('id', 'string'))\n    //    await user.destroy()\n    //    this.noContent()\n  }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["All of the implementations are commented out to protect us from accidentally exposing an endpoint you never meant to, but they should be close to what you need out of the box, provided you follow our very basic authentication pattern set up for you in ",(0,t.jsx)(n.code,{children:"AuthedController.ts"})," (which will be covered shortly)."]}),"\n",(0,t.jsx)(n.p,{children:"A migration is also generated for you, which describes the attributes you provided in the generator. Let's add notNull to our email, password, and role columns:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"import { Kysely, sql } from 'kysely'\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport async function up(db: Kysely<any>): Promise<void> {\n  await db.schema\n    .createType('user_roles_enum')\n    .asEnum(['App', 'Admin'])\n    .execute()\n\n  await db.schema\n    .createTable('users')\n    .addColumn('id', 'bigserial', (col) => col.primaryKey())\n    .addColumn('email', 'varchar(255)', (col) => col.notNull())\n    .addColumn('password_digest', 'varchar(255)', (col) => col.notNull())\n    .addColumn('user_role', sql`user_roles_enum`, (col) => col.notNull())\n    .addColumn('created_at', 'timestamp', (col) => col.notNull())\n    .addColumn('updated_at', 'timestamp', (col) => col.notNull())\n    .execute()\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport async function down(db: Kysely<any>): Promise<void> {\n  await db.schema.dropTable('users').execute()\n  await db.schema.dropType('user_roles_enum').execute()\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Let's run these migrations to get our databases set up and our schemas built. Since this is our first time, we will go ahead and just reset our databases, which will automatically drop them (if they exist) then recreate them, then run migrations on them and do all the necessary introspection to build the schema files for dream and kysely."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"NODE_ENV=test yarn psy db:reset\nNODE_ENV=development yarn psy db:reset\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This will, amongst a few other things, generate the ",(0,t.jsx)(n.code,{children:"schema.ts"})," file, which helps dream and psychic provide a rich type experience for the developer, as well as provide automatic param validation mechanisms, etc..."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"// api/src/db/schema.ts\n\nimport { CalendarDate } from '@rvohealth/dream'\nimport { DateTime } from 'luxon'\nimport { UserRolesEnumValues, IdType, UserRolesEnum } from './sync'\n\nexport const schema = {\n  users: {\n    columns: {\n      createdAt: {\n        coercedType: {} as DateTime,\n        enumType: null,\n        enumValues: null,\n        dbType: 'timestamp without time zone',\n        allowNull: false,\n        isArray: false,\n      },\n      email: {\n        coercedType: {} as string | null,\n        enumType: null,\n        enumValues: null,\n        dbType: 'character varying',\n        allowNull: true,\n        isArray: false,\n      },\n      id: {\n        coercedType: {} as IdType,\n        enumType: null,\n        enumValues: null,\n        dbType: 'bigint',\n        allowNull: false,\n        isArray: false,\n      },\n      passwordDigest: {\n        coercedType: {} as string | null,\n        enumType: null,\n        enumValues: null,\n        dbType: 'character varying',\n        allowNull: true,\n        isArray: false,\n      },\n      updatedAt: {\n        coercedType: {} as DateTime,\n        enumType: null,\n        enumValues: null,\n        dbType: 'timestamp without time zone',\n        allowNull: false,\n        isArray: false,\n      },\n      userRole: {\n        coercedType: {} as UserRolesEnum | null,\n        enumType: {} as UserRolesEnum,\n        enumValues: UserRolesEnumValues,\n        dbType: 'user_roles_enum',\n        allowNull: true,\n        isArray: false,\n      },\n    },\n    virtualColumns: [],\n    associations: {},\n  },\n} as const\n"})}),"\n",(0,t.jsx)(n.p,{children:"A simple factory was generated earlier, as well as a model spec and controller spec, which are both empty (for now). Let's add some specs to fulfull an authentication pattern. we will need a signup pattern, a signin pattern, and some kind of auth check pattern to get us going. For starters, let's create two controller specs, one for our authentication controller, and one to just return a status if the user is logged in."}),"\n",(0,t.jsxs)(n.p,{children:["Let's start with the ",(0,t.jsx)(n.code,{children:"AuthController.spec.ts"})," file:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"// api/spec/unit/controllers/Api/V1/AuthedController.spec.ts\n\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\nimport { describe as context } from '@jest/globals'\nimport { Encrypt } from '@rvohealth/psychic'\nimport User from '../../../../../src/app/models/User'\nimport { UpdateableProperties } from '@rvohealth/dream'\nimport createUser from '../../../../factories/UserFactory'\nimport { specRequest as request } from '@rvohealth/psychic/spec-helpers'\n\ndescribe('ApiV1AuthController', () => {\n  beforeEach(async () => {\n    await request.init()\n  })\n\n  describe('POST /api/v1/signup', () => {\n    function subject(params: UpdateableProperties<User>, expectedStatus: number) {\n      return request.post('/api/v1/signup', expectedStatus, { data: params })\n    }\n\n    it('creates a user', async () => {\n      await subject({ email: 'how@yadoin', password: 'password' }, 201)\n      const user = await User.first()\n      expect(user.email).toEqual('how@yadoin')\n      expect(await user.checkPassword('password')).toEqual(true)\n    })\n  })\n\n  describe('POST /api/v1/signin', () => {\n    let user: User\n\n    beforeEach(async () => {\n      user = await createUser({ email: 'how@yadoin', password: 'password' })\n    })\n\n    function subject(email: string, password: string, expectedStatus: number) {\n      return request.post('/api/v1/signin', expectedStatus, { data: { email, password } })\n    }\n\n    it('signs in a user', async () => {\n      await subject('how@yadoin', 'password', 204)\n    })\n\n    context('with invalid credentials', () => {\n      it('returns 401', async () => {\n        await subject('how@yadoin', 'notpassword', 401)\n      })\n    })\n  })\n})\n"})}),"\n",(0,t.jsxs)(n.p,{children:["and our ",(0,t.jsx)(n.code,{children:"UsersController.spec.ts"})," file:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"// api/spec/unit/controllers/Api/V1/UsersController.spec.ts\n\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\nimport { PsychicServer } from '@rvohealth/psychic'\nimport createUser from '../../../../factories/UserFactory'\nimport { specRequest as request } from '@rvohealth/psychic/spec-helpers'\n\nconst server = new PsychicServer()\n\ndescribe('ApiV1UsersController', () => {\n  beforeEach(async () => {\n    await request.init()\n  })\n\n  describe('GET /api/v1/users/me', () => {\n    async function getSession() {\n      return await request.session('/api/v1/signin', { email: 'how@yadoin', password: 'password' }, 204)\n    }\n\n    it('returns 204 with an authed user', async () => {\n      await createUser({ email: 'how@yadoin', password: 'password' })\n      const session = await getSession()\n      await session.get('/api/v1/users/me').expect(204)\n    })\n\n    it('returns 401 with no authed user', async () => {\n      await createUser({ email: 'how@yadoin', password: 'password' })\n      await request.get('/api/v1/users/me', 401)\n    })\n  })\n})\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Right away upon writing these, we can see that there is some missing behavior and methods on the ",(0,t.jsx)(n.code,{children:"User"})," model. Let's add specs to cover those as well!"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"// spec/unit/models/User.spec.ts\n\nimport { describe as context } from '@jest/globals'\nimport { Hash } from '@rvohealth/psychic'\nimport createUser from '../../factories/UserFactory'\n\ndescribe('User', () => {\n  context('upon saving a password', () => {\n    it('hashes the password and stores it in the db', async () => {\n      const user = await createUser({\n        email: 'how@yadoin',\n        password: 'password',\n      })\n      expect(user.password).toBeUndefined()\n      expect(await Hash.check('password', user.passwordDigest)).toEqual(true)\n    })\n  })\n\n  describe('#checkPassword', () => {\n    it('returns true with a valid password', async () => {\n      const user = await createUser({\n        email: 'how@yadoin',\n        password: 'password',\n      })\n      expect(await user.checkPassword('password')).toEqual(true)\n    })\n\n    it('returns false with an invalid password', async () => {\n      const user = await createUser({\n        email: 'how@yadoin',\n        password: 'password',\n      })\n      expect(await user.checkPassword('passwordz')).toEqual(false)\n    })\n  })\n})\n"})}),"\n",(0,t.jsx)(n.p,{children:"Let's make sure our specs are failing before we proceed:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"yarn uspec\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This should have produced some errors for us. Let's get them passing by adding some implementation. We will start by fulfilling our failing User spec by adding a ",(0,t.jsx)(n.code,{children:"Virtual"})," column called ",(0,t.jsx)(n.code,{children:"password"})," on the ",(0,t.jsx)(n.code,{children:"User"})," model, and then leveraging model hooks to make sure to hash the password before storing it. We will also need to add a ",(0,t.jsx)(n.code,{children:"checkPassword"})," method to verify passwords from our controller."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"// api/src/app/models/User.ts\n\nimport { BeforeSave, DreamColumn, Virtual } from '@rvohealth/dream'\nimport ApplicationModel from './ApplicationModel'\nimport UserSerializer, {\n  UserSummarySerializer,\n} from '../../../src/app/serializers/UserSerializer'\nimport { Hash } from '@rvohealth/psychic'\n\nexport default class User extends ApplicationModel {\n  ...\n  @Virtual()\n  public password: string | undefined\n\n  @BeforeSave()\n  public async hashPassword() {\n    if (this.password) this.passwordDigest = await Hash.gen(this.password)\n    this.password = undefined\n  }\n\n  public async checkPassword(plaintextPassword: string) {\n    return await Hash.check(plaintextPassword, this.passwordDigest)\n  }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"now let's run our user specs:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"yarn uspec models/User.spec.ts\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This should get our specs to go green for the User model, now let's focus on implementation for our controllers. Let's start with the ",(0,t.jsx)(n.code,{children:"AuthController"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"// api/src/app/controllers/api/v1/AuthController.ts\n\nimport { PsychicController, BeforeAction, Encrypt } from '@rvohealth/psychic'\nimport User from '../models/User'\n\nexport default class AuthedController extends PsychicController {\n  protected currentUser: User\n\n  @BeforeAction()\n  public async authenticate() {\n    const userId = this.getCookie('token')\n    const user = await User.find(userId)\n    if (!user) return this.unauthorized()\n\n    this.currentUser = user\n  }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This means that any controller extending AuthedController will reject a request that does not have a token present that points to a valid user model when decrypted. Under the hood, any cookie stored with psychic is always encrypted using the ",(0,t.jsx)(n.code,{children:"Encrypt"})," library provided by psychic, which will simply use bcrypt under the hood, along with the ",(0,t.jsx)(n.code,{children:"APP_ENCRYPTION_KEY"})," that is autogenerated for your development and test environments."]}),"\n",(0,t.jsx)(n.p,{children:"Finally, we will just fill in the implementation for out controllers to fulfill the last of our specs:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"// api/src/app/controllers/api/v1/UsersController.ts\n\nimport AuthedController from '../../AuthedController'\n\nexport default class ApiV1UsersController extends AuthedController {\n  public async me() {\n    if (!this.currentUser) return this.unauthorized()\n    this.noContent()\n  }\n}\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"// api/src/app/controllers/api/v1/AuthController.ts\n\nimport User from '../../../models/User'\nimport { Encrypt, PsychicController } from '@rvohealth/psychic'\n\nexport default class ApiV1AuthController extends PsychicController {\n  public async signup() {\n    const user = await User.create(this.paramsFor(User))\n    this.created(user.id)\n  }\n\n  public async signin() {\n    const email = this.castParam('email', 'string')\n    const password = this.castParam('password', 'string')\n    const user = await User.findBy({ email })\n    if (!user) return this.unauthorized()\n\n    const validPassword = await user.checkPassword(password)\n    if (!validPassword) return this.unauthorized()\n\n    this.setCookie('token', user.id.toString())\n    this.noContent()\n  }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"now we can see all specs going green:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"yarn uspec\n"})}),"\n",(0,t.jsxs)(n.p,{children:["NOTE: All cookies are automatically encrtpyed, httpOnly, and 31 days long. If you to override any defaults or pass additional options, you can always pass a third argument to ",(0,t.jsx)(n.code,{children:"setCookie"})," to apply those overrides. However, if it is maxAge you need to set, you can simply adjust the default values set in ",(0,t.jsx)(n.code,{children:"conf/app.ts"})," under ",(0,t.jsx)(n.code,{children:"psy.setCookieOptions"}),", which will apply by default to all cookies being set (unless explicitly overridden)."]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},6592:(e,n,s)=>{s.d(n,{A:()=>r});var t=s(4848);function r(e){let{children:n}=e;return(0,t.jsx)("div",{className:"right-sidebar-item",children:n})}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>i});var t=s(6540);const r={},a=t.createContext(r);function o(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);