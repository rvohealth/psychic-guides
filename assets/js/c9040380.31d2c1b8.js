"use strict";(self.webpackChunkpsychic_guides=self.webpackChunkpsychic_guides||[]).push([[2468],{3246:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>a,toc:()=>d});var t=n(4848),i=n(8453);const r={sidebar_position:1},o="unit",a={id:"specs/unit",title:"unit",description:"Unit specs are meant for testing strictly your backend components in isolation. They do not launch your server or front end. The config for them is located in spec/unit/jest.config.js. Composing unit specs, one is enabled to test all components of their app. Since this is all done using jest under the hood, this will likely be familiar to you already, with the one caviat that we also provide special unit spec helpers for spec'ing your endpoints.",source:"@site/docs/specs/unit.mdx",sourceDirName:"specs",slug:"/specs/unit",permalink:"/docs/specs/unit",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/specs/unit.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"guides",previous:{title:"render",permalink:"/docs/serializers/render"},next:{title:"feature",permalink:"/docs/specs/feature"}},c={},d=[{value:"general specs",id:"general-specs",level:2},{value:"models",id:"models",level:3},{value:"serializers",id:"serializers",level:3},{value:"controller/endpoint specs",id:"controllerendpoint-specs",level:2}];function l(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.h1,{id:"unit",children:"unit"}),"\n",(0,t.jsxs)(s.p,{children:["Unit specs are meant for testing strictly your backend components in isolation. They do not launch your server or front end. The config for them is located in ",(0,t.jsx)(s.code,{children:"spec/unit/jest.config.js"}),". Composing unit specs, one is enabled to test all components of their app. Since this is all done using ",(0,t.jsx)(s.code,{children:"jest"})," under the hood, this will likely be familiar to you already, with the one caviat that we also provide special unit spec helpers for spec'ing your endpoints."]}),"\n",(0,t.jsx)(s.h2,{id:"general-specs",children:"general specs"}),"\n",(0,t.jsxs)(s.p,{children:["For the most part, your app can be spec'd using the general tools provided by ",(0,t.jsx)(s.a,{href:"https://jestjs.io/docs/getting-started",children:"jest"}),". We provide some boilerplate setup for your unit spec runs to make sure that the database is truncated between runs, which allows you to freely seed the db for each test without worrying about running into data from a previous test run:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ts",children:"// api/spec/unit/setup/hooks.ts\n\nimport { truncate } from '@rvohealth/dream/spec-helpers'\n\nbeforeEach(async () => {\n  await truncate()\n})\n"})}),"\n",(0,t.jsx)(s.h3,{id:"models",children:"models"}),"\n",(0,t.jsx)(s.p,{children:"Write model specs to enfore behavior for your models, like so:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ts",children:"// api/spec/unit/models/User.spec.ts\n\nimport { describe as context } from '@jest/globals'\nimport { Hash } from '@rvohealth/psychic'\nimport createUser from '../../factories/UserFactory'\n\ndescribe('User', () => {\n  context('upon saving a password', () => {\n    it('hashes the password and stores it in the db', async () => {\n      const user = await createUser({\n        email: 'how@yadoin',\n        password: 'password',\n      })\n      expect(user.password).toBeUndefined()\n      expect(await Hash.check('password', user.passwordDigest)).toEqual(true)\n    })\n  })\n\n  describe('#checkPassword', () => {\n    let user: User\n\n    beforeEach(async () => {\n      user = await createUser({\n        email: 'how@yadoin',\n        password: 'password',\n      })\n    })\n\n    it('returns true with a valid password', async () => {\n      expect(await user.checkPassword('password')).toEqual(true)\n    })\n\n    it('returns false with an invalid password', async () => {\n      expect(await user.checkPassword('passwordz')).toEqual(false)\n    })\n  })\n})\n"})}),"\n",(0,t.jsx)(s.h3,{id:"serializers",children:"serializers"}),"\n",(0,t.jsx)(s.p,{children:"We don't generally encourage developers to write serializer specs (since this is normally covered by endpoint tests), but sometimes it can make sense if the rendering logic gets to be fairly complex. In that case, you can test your serializers like this:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ts",children:"describe('UserSerializer', () => {\n  it('renders loginCount', async () => {\n    const user = await createUser({ email: 'how@yadoin', password: 'password' })\n    expect(new Serializer(user).render()).toEqual(\n      expect.objectContaining({ loginCount: 0 })\n    )\n  })\n})\n"})}),"\n",(0,t.jsx)(s.p,{children:"Anything else in the app should be fairly straight forward to test, with the exception of controller/endpoint tests, which we will cover next."}),"\n",(0,t.jsx)(s.h2,{id:"controllerendpoint-specs",children:"controller/endpoint specs"}),"\n",(0,t.jsx)(s.p,{children:"Under the hood, psychic provides some test helpers to make our lives easier when needing to run controller/endpoint tests:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ts",children:"import { specRequest as request } from '@rvohealth/psychic/spec-helpers'\n\ndescribe('a visitor attempts to hit an unauthed route', () => {\n  beforeEach(async () => {\n    await request.init()\n  })\n\n  it('accepts the request', async () => {\n    await request.get('/ping', 200)\n  })\n})\n"})}),"\n",(0,t.jsx)(s.p,{children:"In addition to routine endpoint tests, one can also test authenticated endpoints using chained sessions, like so:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ts",children:"describe('an authed user attempts to hit an authed route', () => {\n  beforeEach(async () => {\n    await createUser({ email: 'how@yadoin', password: 'password' })\n    await request.init()\n  })\n\n  it('returns 200', async () => {\n    const session = await request.session(\n      '/api/v1/signin',\n      { email: 'how@yadoin', password: 'password' },\n      204\n    )\n    await session.get('/api/v1/users/me').expect(200)\n  })\n})\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Calling ",(0,t.jsx)(s.code,{children:"request.session"})," here is very similar to ",(0,t.jsx)(s.code,{children:"request.post"}),", but with the caviat that a ",(0,t.jsx)(s.a,{href:"https://www.npmjs.com/package/supertest",children:"supertest"})," instance will be returned, which can be used to drive assertions on additional endpoints without losing access to the cookies established during the ",(0,t.jsx)(s.code,{children:"send.session"})," call."]}),"\n",(0,t.jsxs)(s.p,{children:["For more information on how to do this, see our ",(0,t.jsx)(s.a,{href:"/docs/getting-started/authenticating",children:"authentication"})," guide, which wires up the mechanisms to enable this to happen."]})]})}function p(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>o,x:()=>a});var t=n(6540);const i={},r=t.createContext(i);function o(e){const s=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(r.Provider,{value:s},e.children)}}}]);