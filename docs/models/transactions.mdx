---
sidebar_position: 11
ai_summary: "Transactions tie the success of multiple queries together, guaranteeing valid database state. Use ApplicationModel.transaction with txn callback. Pass txn to queries using .txn(txn) method. Methods that rely on foreign key violations (like createOrFindBy) cannot be used in transactions."
---

# transactions

Transactions are useful if you want to tie the success of one query to another, enabling you to guarantee a valid state for your database in the event that anything might go wrong:

```ts
await ApplicationModel.transaction(async txn => {
  const user = await User.txn(txn).create({ ... })
  await UserSettings.txn(txn).create({ user })
})
```

The pattern for this can seem strange at first, but you will get the hang of it in short order. To instantiate a transaction, you will call the static `transaction` method on your app's ApplicationModel, capturing the provided transaction in the callback function you provide, named `txn` by convention. With the txn variable on hand, you proceed to pass it to each subsequent query that might need it, as demonstrated above, using the `txn` method (named the same as the variable).

Once in a transaction builder (done by calling the `txn` method), you will be prohibited from using methods that take advantage of errors with foreign key violations, like `createOrFindBy`, since they will not function properly in a transaction.
