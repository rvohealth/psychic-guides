---
sidebar_position: 1
---

# psychic

Psychic exposes a few different configuration points within the `conf` directory, but most of the configuration is done in `conf/app.ts`. This file enables you to express the underlying configuration for your psychic application, including encryption keys, cookie configurations, and much more.

```
├── app
│   ├── conf
│   │   ├── app.ts             // main psychic config
│   │   ├── dream.ts           // dream bindings
│   │   ├── global.ts          // loaded by app entry points
│   │   ├── inflections.ts     // loaded by app entry points
│   │   ├── loadEnv.ts         // loaded by app entry points
│   │   ├── repl.ts            // entry point for console
│   │   ├── routes.ts          // describes your application routes
│   │   ├── routeTypes.ts      // autogenerated by psychic
```

## conf/app.ts

The `conf/app.ts` file is the primary configuration entrypoint for Psychic applications. In here, you can specify your cookie configuration, encryption keys, as well as integration options for redis, socket.io, bullmq, etc...

### set method

The `set` method is the primary method used to configure a Psychic application. The first argument to the `set` call is the specific configuration option that you want to adjust, such as `appName`, or `useRedis`. Based on what is provided to the first argument, careful type helpers will guide you through specifying the second argument, which will be different based on what was provided to the first argument.

Below is a brief example of some of the settings that can be adjusted, while each option will be carefully illustrated in the subsequent sections of this guide.

```ts
export default (psy: Psyconf) => {
  psy.set('appName', 'howyadoin')
  psy.set('useWs', true)
  psy.set('useRedis', true)
  psy.set('apiOnly', false)
  psy.set('encryption', {
    cookies: {
      current: {
        algorithm: 'aes-256-gcm',
        key: process.env.APP_ENCRYPTION_KEY!,
      },
    },
  })
  psy.set('apiRoot', path.join(__dirname, '..', '..'))
  psy.set('clientRoot', path.join(__dirname, '..', '..', '..', 'client'))
  psy.set('inflections', inflections)
  psy.set('routes', routesCb)
  // ...etc
}
```

### appName

This configuration informs Psychic what your app's name is, which is primarily used for logging purposes.

```ts
export default (psy: Psyconf) => {
  psy.set('appName', 'howyadoin')
  ...
}
```

### useWs

The `useWs` configuration option informs Psychic whether or not you would like to utilize the built-in socket.io integration. If your app is needing websockets, we highly recommend utilizing this functionality, as well as turning on `useRedis`, since they work together to provide a scalable, distributed websocket system that is otherwise fairly hard to build out on your own.

```ts
export default (psy: Psyconf) => {
  psy.set('useWs', true)
  psy.set('useRedis', true)
  ...
}
```

### useRedis

The `useRedis` configuration option informs Psychic whether or not you would like to utilize the built-in redis integration. The redis integration is useful for 3 things in your Psychic application:

1. It supports the built-in socket.io integration (activated by setting `useWs` to `true`). With redis enabled, Psychic is able to supercharge your socket.io integration with redis's pub-sub functionality, which enables you to always be able to broadcast to a user, no matter which server they are currently connected to within your system. This essentially takes care of your scaling needs with websockets automatically, and is highly recommended if you plan to enable websockets within your application. For more information on socket.io and redis integration, see [this article from socket.io](https://socket.io/docs/v4/redis-adapter).

2. It supports background jobs, a powerful feature provided out of the box by Psychic that enables your app to easily run jobs in the background. This feature is powered by [bullmq](https://docs.bullmq.io), a powerful node-based queing system that enables you to offload intensive work to background workers, which is useful to prevent your webservers from taking on intensive jobs, since they need to be availble to respond to new web traffic. We recommend turning this on, since it is highly useful for building scalable web applications.

```ts
export default (psy: Psyconf) => {
  psy.set('useRedis', true)
  ...
}
```

### apiOnly

The `apiOnly` configuration option informs Psychic whether or not you are attaching a web application directly to this application. If you are building a front end to couple to your application, we recommend you turn this on, since it enables you to run feature tests with [playwrite](https://playwright.dev), a testing tool which runs a headless browser through your client application and connects to a Psychic test application. This tool is extremely powerful, and completely front-end agnostic, enabling you to build your front end however you want and connect it seamlessly with Psychic for testing.

```ts
export default (psy: Psyconf) => {
  psy.set('apiOnly', true)
  ...
}
```

### apiRoot

The `apiRoot` configuration option specifies the root of your backend application. If you are building an api-only application, this would just be the path to your project root. However, if you are building with a client application, this would be the path to the `api` folder within your project root.

```ts
export default (psy: Psyconf) => {
  psy.set('apiRoot', path.join(__dirname, '..', '..'))
  ...
}
```

### clientRoot

The `clientRoot` configuration option specifies the root of your client (front end) application. If you are building an api-only application, you would not set this. Otherwise, it would be the path to your front-end application, usually located at `/client`.

```ts
export default (psy: Psyconf) => {
  psy.set('clientRoot', path.join(__dirname, '..', '..', '..', 'client'))
  ...
}
```

### inflections

The `inflections` configuration option provides both Psychic and Dream with pluralization information specific to the DSL of your application. This is useful when utilizing generators, which will automatically perform pluralization operations on provided arguments to generate files within your application. This is all being drivin under the hood by the [pluralize](https://github.com/plurals/pluralize) package.

```ts
// conf/inflections.ts
import pluralize from 'pluralize'

export default function inflections() {
  pluralize.addUncountableRule('paper')
}

// conf/app.ts
import inflections from './inflections'

export default (psy: Psyconf) => {
  psy.set('inflections', inflections)
  ...
}
```

### routes

The `routes` configuration option provides Psychic with the routing schema for your webserver. More information about configuring routes can be found in our [routing guides](/docs/routing/overview).

```ts
// conf/routes.ts
export default function routes(r: PsychicRouter) {
  r.get('/', WelcomeController, 'home')
}

// conf/app.ts
import routes from './routes'

export default (psy: Psyconf) => {
  psy.set('routes', routes)
  ...
}
```

### json

Use the `Psychonf#set` method to apply json (body parser) options. Json options are driven through the [body-parser](https://www.npmjs.com/package/body-parser) package.

```ts
export default (psy: Psyconf) => {
  psy.set('json', {
    limit: '20kb',
  })
}
```

### cookie

Use the `Psychonf#set` method to apply cookie options. Cookie options are driven through the express-cookie package.

```ts
export default (psy: Psyconf) => {
  // set options for cookie usage
  psy.set('cookie', {
    maxAge: {
      days: 14,
      hours: 0,
      minutes: 0,
      seconds: 0,
      milliseconds: 0,
    },
  })
}
```

### encryption

Use the `Psychonf#set` method to apply encryption options.

```ts
export default (psy: Psyconf) => {
  psy.set('encryption', {
    cookies: {
      current: {
        algorithm: 'aes-256-gcm',
        key: process.env.APP_ENCRYPTION_KEY!,
      },
      // legacy is used when you are in the process of switching out your encryption keys
      legacy: {
        algorithm: 'aes-256-gcm',
        key: process.env.LEGACY_APP_ENCRYPTION_KEY!,
      },
    },
  })
}
```

### cors

Use the `Psychonf#set` method to apply cors options. Cors options are driven through the express-cors package.

```ts
export default (psy: Psyconf) => {
  // set options for cors
  psy.set('cors', {
    credentials: true,
    origin: [process.env.CLIENT_HOST || 'http://localhost:3000'],
  })
}
```

### redis

Use the `Psychonf#set` method to apply redis options. Redis options are driven by the [node-redis](https://github.com/redis/node-redis) package.

```ts
export default (psy: Psyconf) => {
  // redis background job credentials
  psy.set('redis:background', {
    username: process.env.BACKGROUND_JOBS_REDIS_USER,
    password: process.env.BACKGROUND_JOBS_REDIS_PASSWORD,
    host: process.env.BACKGROUND_JOBS_REDIS_HOST,
    port: process.env.BACKGROUND_JOBS_REDIS_PORT,
    secure: process.env.BACKGROUND_JOBS_REDIS_USE_SSL === '1',
  })

  // redis websocket credentials
  psy.set('redis:ws', {
    username: process.env.WS_REDIS_USER,
    password: process.env.WS_REDIS_PASSWORD,
    host: process.env.WS_REDIS_HOST,
    port: process.env.WS_REDIS_PORT,
    secure: process.env.WS_REDIS_USE_SSL === '1',
  })
}
```

### background job options

Use the `Psychonf#set` method to apply background queue options. Since background jobs are driven by BullMQ, the options here are passed to the job instance of the BullMQ package.

```ts
export default (psy: Psyconf) => {
  // configuration options for bullmq queue (used for running background jobs in redis)
  psy.set('background:queue', {
    defaultJobOptions: {
      removeOnComplete: 1000,
      removeOnFail: 20000,
      // 524,288,000 ms (~6.1 days) using algorithm:
      // "2 ^ (attempts - 1) * delay"
      attempts: 20,
      backoff: {
        type: 'exponential',
        delay: 1000,
      },
    },
  })

  // configuration options for bullmq worker (used for running background jobs in redis)
  psy.set('background:worker', {})
}
```

### hooks

Hooks are called during specific lifecycle events in the server initialization process.

```ts
export default (psy: PsychicConfig) => {
  // run once an express app is initialized by the psychic server
  psy.on('express:init', (app) => {
    if (!testEnv() || process.env.REQUEST_LOGGING === '1') {
      const SENSITIVE_FIELDS = [
        'password',
        'token',
        'authentication',
        'authorization',
        'secret',
      ]

      app.use(
        expressWinston.logger({
          transports: [new winston.transports.Console()],
          format: winston.format.combine(
            winston.format.colorize(),
            winston.format.json(),
          ),
          meta: true, // optional: control whether you want to log the meta data about the request (default to true)
          msg: 'HTTP {{req.method}} {{req.url}}', // optional: customize the default logging message. E.g. "{{res.statusCode}} {{req.method}} {{res.responseTime}}ms {{req.url}}"
          expressFormat: true, // Use the default Express/morgan request formatting. Enabling this will override any msg if true. Will only output colors with colorize set to true
          colorize: false, // Color the text and status code, using the Express/morgan color palette (text: gray, status: default green, 3XX cyan, 4XX yellow, 5XX red).
          headerBlacklist: [
            'authorization',
            'content-length',
            'connection',
            'cookie',
            'sec-ch-ua',
            'sec-ch-ua-mobile',
            'sec-ch-ua-platform',
            'sec-fetch-dest',
            'sec-fetch-mode',
            'sec-fetch-site',
            'user-agent',
          ],
          ignoredRoutes: ['/health_check'],
          bodyBlacklist: SENSITIVE_FIELDS,
        }),
      )
    }
  })

  // run a callback on server boot (but before routes are processed)
  psy.on('boot', () => {})

  // run a callback after routes are done processing
  psy.on('after:routes', () => {})

  // run a callback after the config is loaded
  psy.on('load', async () => {
    // uncomment to initialize background jobs
    // (this should only be done if useRedis is true)
    await background.connect()
  })

  // run a callback after the config is loaded, but only if NODE_ENV=development
  psy.on('load:dev', () => {})

  // run a callback after the config is loaded, but only if NODE_ENV=test
  psy.on('load:test', () => {})

  // run a callback after the config is loaded, but only if NODE_ENV=production
  psy.on('load:prod', () => {})

  // this function will be run any time a server error is encountered
  // that psychic isn't sure how to respond to (i.e. 500 internal server errors)
  psy.on('server:error', (err, _, res) => {
    if (!res.headersSent) res.sendStatus(500)
    else if (developmentOrTestEnv()) throw err
  })

  // run a callback after the websocket server is initially started
  psy.on('ws:start', () => {})

  // run a callback after connection to the websocket service
  psy.on('ws:connect', () => {})
}
```
