---
sidebar_position: 1
---

# psychic

Psychic exposes a few different configuration points within the `conf` directory, but most of the configuration is done in `conf/app.ts`. This file enables you to express the underlying configuration for your psychic application, including encryption keys, cookie configurations, and much more.

```
├── app
│   ├── conf
│   │   ├── app.ts             // main psychic config
│   │   ├── dream.ts           // dream bindings
│   │   ├── global.ts          // loaded by app entry points
│   │   ├── inflections.ts     // loaded by app entry points
│   │   ├── loadEnv.ts         // loaded by app entry points
│   │   ├── repl.ts            // entry point for console
│   │   ├── routes.ts          // describes your application routes
│   │   ├── routeTypes.ts      // autogenerated by psychic
```

## conf/app.ts

The `conf/app.ts` file is the primary configuration entrypoint for Psychic applications. In here, you can specify your cookie configuration, encryption keys, as well as integration options for redis, socket.io, bullmq, etc...

### set method

The `set` method is the primary method used to configure a Psychic application. The first argument to the `set` call is the specific configuration option that you want to adjust, such as `appName`, or `apiOnly`. Based on what is provided to the first argument, careful type helpers will guide you through specifying the second argument, which will be different based on what was provided to the first argument.

Below is a brief example of some of the settings that can be adjusted, while each option will be carefully illustrated in the subsequent sections of this guide.

```ts
export default (psy: Psyconf) => {
  psy.set('appName', 'howyadoin')
  psy.set('apiOnly', false)
  psy.set('encryption', {
    cookies: {
      current: {
        algorithm: 'aes-256-gcm',
        key: AppEnv.string('APP_ENCRYPTION_KEY'),
      },
    },
  })
  psy.set('apiRoot', path.join(__dirname, '..', '..'))
  psy.set('clientRoot', path.join(__dirname, '..', '..', '..', 'client'))
  psy.set('inflections', inflections)
  psy.set('routes', routesCb)
  // ...etc
}
```

### appName

This configuration informs Psychic what your app's name is, which is primarily used for logging purposes.

```ts
export default (psy: Psyconf) => {
  psy.set('appName', 'howyadoin')
  ...
}
```

### apiOnly

The `apiOnly` configuration option informs Psychic whether or not you are attaching a web application directly to this application. If you are building a front end to couple to your application, we recommend you turn this on, since it enables you to run feature tests with [playwrite](https://playwright.dev), a testing tool which runs a headless browser through your client application and connects to a Psychic test application. This tool is extremely powerful, and completely front-end agnostic, enabling you to build your front end however you want and connect it seamlessly with Psychic for testing.

```ts
export default (psy: Psyconf) => {
  psy.set('apiOnly', true)
  ...
}
```

### apiRoot

The `apiRoot` configuration option specifies the root of your backend application. If you are building an api-only application, this would just be the path to your project root. However, if you are building with a client application, this would be the path to the `api` folder within your project root.

```ts
export default (psy: Psyconf) => {
  psy.set('apiRoot', path.join(__dirname, '..', '..'))
  ...
}
```

### clientRoot

The `clientRoot` configuration option specifies the root of your client (front end) application. If you are building an api-only application, you would not set this. Otherwise, it would be the path to your front-end application, usually located at `/client`.

```ts
export default (psy: Psyconf) => {
  psy.set('clientRoot', path.join(__dirname, '..', '..', '..', 'client'))
  ...
}
```

### inflections

The `inflections` configuration option provides both Psychic and Dream with pluralization information specific to the DSL of your application. This is useful when utilizing generators, which will automatically perform pluralization operations on provided arguments to generate files within your application. This is all being drivin under the hood by the [pluralize](https://github.com/plurals/pluralize) package.

```ts
// conf/inflections.ts
import pluralize from 'pluralize'

export default function inflections() {
  pluralize.addUncountableRule('paper')
}

// conf/app.ts
import inflections from './inflections'

export default (psy: Psyconf) => {
  psy.set('inflections', inflections)
  ...
}
```

### routes

The `routes` configuration option provides Psychic with the routing schema for your webserver. More information about configuring routes can be found in our [routing guides](/docs/routing/overview).

```ts
// conf/routes.ts
export default function routes(r: PsychicRouter) {
  r.get('/', WelcomeController, 'home')
}

// conf/app.ts
import routes from './routes'

export default (psy: Psyconf) => {
  psy.set('routes', routes)
  ...
}
```

### json

Use the `PsychicApplication#set` method to apply json (body parser) options. Json options are driven through the [body-parser](https://www.npmjs.com/package/body-parser) package.

```ts
export default (psy: Psyconf) => {
  psy.set('json', {
    limit: '20kb',
  })
}
```

### cookie

Use the `PsychicApplication#set` method to apply cookie options. Cookie options are driven through the express-cookie package.

```ts
export default (psy: Psyconf) => {
  // set options for cookie usage
  psy.set('cookie', {
    maxAge: {
      days: 14,
      hours: 0,
      minutes: 0,
      seconds: 0,
      milliseconds: 0,
    },
  })
}
```

### ssl

Encryption between the load balancer and your Psychic webservers is an important part of encryption-in-transit. This SSL certificate will be a self-signed certificate. It is separate from the SSL certificate that you'll install on your load balancer.

```ts
export default (psy: Psyconf) => {
  if (AppEnv.isProduction) {
    psy.set('ssl', {
      key: AppEnv.string('SSL_KEY_PATH'),
      cert: AppEnv.string('SSL_CERT_PATH'),
    })
  }
}
```

### encryption

Use the `PsychicApplication#set` method to apply encryption options.

```ts
export default (psy: Psyconf) => {
  psy.set('encryption', {
    cookies: {
      current: {
        algorithm: 'aes-256-gcm',
        key: AppEnv.string('APP_ENCRYPTION_KEY'),
      },
      // legacy is used when you are in the process of switching out your encryption keys
      legacy: {
        algorithm: 'aes-256-gcm',
        key: AppEnv.string('LEGACY_APP_ENCRYPTION_KEY'),
      },
    },
  })
}
```

### cors

Use the `PsychicApplication#set` method to apply cors options. Cors options are driven through the express-cors package.

```ts
export default (psy: Psyconf) => {
  // set options for cors
  psy.set('cors', {
    credentials: true,
    origin: [AppEnv.string('CLIENT_HOST') || 'http://localhost:3000'],
  })
}
```

### background jobs

Use the `PsychicApplication#set` method to apply background options. Background options are driven by [BullMQ](https://bullmq.io) package. Psychic provides an intuitive abstraction around BullMQ to make setting up queues easier for you, which enables you to drive your application with simplified configurations.

To simplify the queue process, Psychic has provided a helpful concept called `workstreams`. Workstreams are essentially queue-worker combinations, allowing you to drive your application with as many Queue/Worker combinations as you would like. By default, Psychic provides a single default workstream, which all jobs will automatically be funneled into unless otherwise specified.

However, you may find it useful to have additional workstreams. This can be useful for, say, segmenting off API calls to a single worker and applying rate limiting on that worker.

```ts
export default (psy: Psyconf) => {
  // redis background job credentials
  psy.set('background', {
    // configures the default workstream, which all jobs will automatically
    // be fed to unless directed otherwise
    defaultWorkstream: {
      // https://docs.bullmq.io/guide/parallelism-and-concurrency
      workerCount: os.cpus().length,
      concurrency: 100,
    },

    // additional workstreams you wish to provide.
    namedWorkstreams: [
      {
        name: 'FacebookApi',
        workerCount: 1,

        // rateLimit argument enables you to throttle your workers, so that
        // they don't trip up rate limiting rules for this API.
        // NOTE: rate limiting is a BullMQ Pro-only feature, so only provide
        // this argument if you are also leveraging BullMQ Pro.
        rateLimit: {
          max: 100_000,
          duration: 1000 * 60 * 60 * 24,
        },
      },
    ],

    // By default, Psychic provides a Queue and Worker class from BullMQ. If you are leveraging
    // BullMQ Pro, you will need to provide the custom Queue and Worker classes from BullMQ.
    providers: {
      Queue: QueuePro,
      Worker: WorkerPro,
    },

    // options to provide to your default queue (leveraged by your default workstream)
    defaultBullMQQueueOptions: {
      defaultJobOptions: {
        removeOnComplete: 1000,
        removeOnFail: 20000,
        // 524,288,000 ms (~6.1 days) using algorithm:
        // "2 ^ (attempts - 1) * delay"
        attempts: 20,
        backoff: {
          type: 'exponential',
          delay: 1000,
        },
      },
    },

    // provide a redis connection for your default queue
    defaultQueueConnection: AppEnv.isProduction
      ? new Cluster(
          [
            {
              host: AppEnv.string('BG_JOBS_REDIS_HOST'),
              port: AppEnv.integer('BG_JOBS_REDIS_PORT'),
            },
          ],
          {
            dnsLookup: (address, callback) => callback(null, address),
            redisOptions: {
              username: AppEnv.string('BG_JOBS_REDIS_USERNAME'),
              password: AppEnv.string('BG_JOBS_REDIS_PASSWORD'),
              tls: AppEnv.isProduction ? {} : undefined,
            },
            enableOfflineQueue: false,
          },
        )
      : new Redis({
          host:
            AppEnv.string('BG_JOBS_REDIS_HOST', { optional: true }) ||
            'localhost',
          port:
            AppEnv.integer('BG_JOBS_REDIS_PORT', { optional: true }) || '6379',
          username: AppEnv.string('BG_JOBS_REDIS_USERNAME', { optional: true }),
          password: AppEnv.string('BG_JOBS_REDIS_PASSWORD', { optional: true }),
          tls: AppEnv.isProduction ? {} : undefined,
          enableOfflineQueue: false,
        }),

    // provide a redis connection for your default workers, which will
    // be working off jobs from the default workstream.
    defaultWorkerConnection: !AppEnv.boolean('WORKER_SERVICE')
      ? undefined
      : AppEnv.isProduction
        ? new Cluster(
            [
              {
                host: AppEnv.string('BG_JOBS_REDIS_HOST'),
                port: AppEnv.integer('BG_JOBS_REDIS_PORT'),
              },
            ],
            {
              dnsLookup: (address, callback) => callback(null, address),
              redisOptions: {
                username: AppEnv.string('BG_JOBS_REDIS_USERNAME'),
                password: AppEnv.string('BG_JOBS_REDIS_PASSWORD'),
                tls: AppEnv.isProduction ? {} : undefined,
                maxRetriesPerRequest: null,
              },
            },
          )
        : new Redis({
            host:
              AppEnv.string('BG_JOBS_REDIS_HOST', { optional: true }) ||
              'localhost',
            port:
              AppEnv.integer('BG_JOBS_REDIS_PORT', { optional: true }) ||
              '6379',
            username: AppEnv.string('BG_JOBS_REDIS_USERNAME', {
              optional: true,
            }),
            password: AppEnv.string('BG_JOBS_REDIS_PASSWORD', {
              optional: true,
            }),
            tls: AppEnv.isProduction ? {} : undefined,
            enableOfflineQueue: false,
          }),

    // if you are deploying new redis instances to connect to, and you have old jobs up
    // that still need to be worked off, then you can use transitionalWorkstreams to maintain
    // a connection to the old redis, allowing you to work off any jobs that still exist in the
    // old queue after deploying the new connection changes. We recommend that you only keep this
    // online for as long as you need to for all workers to work off all jobs on this connection.
    // once the queue is empty, send up a deployment to remove transitionalWorkstreams.
    transitionalWorkstreams: AppEnv.isProduction
      ? {
          defaultQueueConnection: new Redis({
            host: AppEnv.string('BACKGROUND_JOBS_REDIS_HOST'),
            port: AppEnv.integer('BACKGROUND_JOBS_REDIS_PORT'),
            username: AppEnv.string('BACKGROUND_JOBS_REDIS_USERNAME'),
            password: AppEnv.string('BACKGROUND_JOBS_REDIS_PASSWORD'),
            tls: AppEnv.isProduction ? {} : undefined,
            enableOfflineQueue: false,
          }),

          defaultWorkerConnection: !AppEnv.string('WORKER_SERVICE')
            ? undefined
            : new Redis({
                host:
                  AppEnv.string('BACKGROUND_JOBS_REDIS_HOST', {
                    optional: true,
                  }) || 'localhost',
                port:
                  AppEnv.integer('BACKGROUND_JOBS_REDIS_PORT', {
                    optional: true,
                  }) || '6379',
                username: AppEnv.string('BACKGROUND_JOBS_REDIS_USERNAME', {
                  optional: true,
                }),
                password: AppEnv.string('BACKGROUND_JOBS_REDIS_PASSWORD', {
                  optional: true,
                }),
                tls: AppEnv.isProduction ? {} : undefined,
                enableOfflineQueue: false,
              }),
        }
      : undefined,
  })
}
```

### websockets

To configure websockets for your Psychic application, you will need to provide a redis connection. This is because the websockets built into Psychic automatically support distributed websocket systems, and leverage redis pub-sub mechanisms to emit websocket events to all your servers.

```ts
export default (psy: Psyconf) => {
  psy.set('websockets', {
    connection: new Redis({
      host: AppEnv.string('WS_REDIS_HOST'),
      port: AppEnv.integer('WS_REDIS_PORT'),
      username: AppEnv.string('WS_REDIS_USERNAME', { optional: true }),
      password: AppEnv.string('WS_REDIS_PASSWORD', { optional: true }),
      tls: AppEnv.isProduction ? {} : undefined,
      maxRetriesPerRequest: null,
    }),
  })
}
```

### hooks

Hooks are called during specific lifecycle events in the server initialization process.

```ts
export default (psy: PsychicConfig) => {
  // run once an express app is initialized by the psychic server
  psy.on('server:init', (app) => {
    if (!testEnv() || AppEnv.boolean('REQUEST_LOGGING')) {
      const SENSITIVE_FIELDS = [
        'password',
        'token',
        'authentication',
        'authorization',
        'secret',
      ]

      app.use(
        expressWinston.logger({
          transports: [new winston.transports.Console()],
          format: winston.format.combine(
            winston.format.colorize(),
            winston.format.json(),
          ),
          ignoredRoutes: ['/health_check'],
          bodyBlacklist: SENSITIVE_FIELDS,
          // ...etc
        }),
      )
    }
  })

  // run a callback on server boot (but before routes are processed)
  psy.on('boot', () => {})

  // run a callback after routes are done processing
  psy.on('after:routes', () => {})

  // run a callback after the config is loaded
  psy.on('load', async () => {
    // uncomment to initialize background jobs
    await background.connect()
  })

  // run a callback after the config is loaded, but only if NODE_ENV=development
  psy.on('load:dev', () => {})

  // run a callback after the config is loaded, but only if NODE_ENV=test
  psy.on('load:test', () => {})

  // run a callback after the config is loaded, but only if NODE_ENV=production
  psy.on('load:prod', () => {})

  // this function will be run any time a server error is encountered
  // that psychic isn't sure how to respond to (i.e. 500 internal server errors)
  psy.on('server:error', (err, _, res) => {
    if (!res.headersSent) res.sendStatus(500)
    else if (developmentOrTestEnv()) throw err
  })

  // run a callback after the websocket server is initially started
  psy.on('ws:start', () => {})

  // run a callback after connection to the websocket service
  psy.on('ws:connect', () => {})
}
```
