---
sidebar_position: 6
---

import RightSidebarItem from '@site/src/components/ui/right-sidebar-item'

# authenticating

Most applications will require some sort of authentication paradigm to resolve tokens or cookies to users in your database. We do not suscribe anyone to one or another pattern, but here we will cover how to do this using entirely psychic-driven tools.

To quickly accelerate things for us, let's use the resource generator to generate:

- a new controller
- a new controller spec
- a new model
- a new model spec
- a new factory
- a new migration
- a new serializer

```bash
$ yarn psy g:resource api/v1/users User email:string password_digest:string role:enum:user_role:App,Admin
```

This will generate the following:

1. A new `User` model

```ts
import { DreamColumn } from '@rvohealth/dream'
import ApplicationModel from './ApplicationModel'
import UserSerializer, {
  UserSummarySerializer,
} from '../../../src/app/serializers/UserSerializer'

export default class User extends ApplicationModel {
  public get table() {
    return 'users' as const
  }

  public get serializers() {
    return {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      default: UserSerializer<any, any>,

      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      summary: UserSummarySerializer<any, any>,
    } as const
  }

  public id: DreamColumn<User, 'id'>
  public email: DreamColumn<User, 'email'>
  public passwordDigest: DreamColumn<User, 'passwordDigest'>
  public userRole: DreamColumn<User, 'userRole'>
  public createdAt: DreamColumn<User, 'createdAt'>
  public updatedAt: DreamColumn<User, 'updatedAt'>
}
```

2. a `UsersController`

```ts
import AuthedController from '../../AuthedController'
import User from '../../../models/User'

export default class ApiV1UsersController extends AuthedController {
  public async create() {
    //    const user = await this.currentUser.createAssociation('users', this.paramsFor(User))
    //    this.created(user)
  }

  public async index() {
    //    const users = await this.currentUser.associationQuery('users').all()
    //    this.ok(users)
  }

  public async show() {
    //    const user = await this.currentUser.associationQuery('users').find(this.castParam('id', 'string'))
    //    this.ok(user)
  }

  public async update() {
    //    const user = await this.currentUser.associationQuery('users').find(this.castParam('id', 'string'))
    //    await user.update(this.paramsFor(User))
    //    this.noContent()
  }

  public async destroy() {
    //    const user = await this.currentUser.associationQuery('users').find(this.castParam('id', 'string'))
    //    await user.destroy()
    //    this.noContent()
  }
}
```

All of the implementations are commented out to protect us from accidentally exposing an endpoint you never meant to, but they should be close to what you need out of the box, provided you follow our very basic authentication pattern set up for you in `AuthedController.ts`:

```ts
import {
  PsychicController,
  BeforeAction,
  // Encrypt,
} from '@rvohealth/psychic'
// import User from '../models/User'

export default class AuthedController extends PsychicController {
  // protected currentUser: User
  @BeforeAction()
  public async authenticate() {
    throw `TODO: Implement authentication scheme!`
    // implement an authentication pattern that ends with you setting
    // this.currentUser to a user. i.e.
    // const token = this.req.headers['token'] as string
    // const userId = Encrypt.decode(token)
    // const user = await User.find(userId)
    // if (!user) return this.forbidden()
    // this.currentUser = await User.find(userId)
  }
}
```

An example authentication pattern is provided for you, but commented out. Let's uncomment it, and we will simply use this as our authentication pattern going forward:

```ts
import { PsychicController, BeforeAction, Encrypt } from '@rvohealth/psychic'
import User from '../models/User'

export default class AuthedController extends PsychicController {
  protected currentUser: User

  @BeforeAction()
  public async authenticate() {
    // implement an authentication pattern that ends with you setting
    // this.currentUser to a user. i.e.

    const token = this.req.headers['token'] as string
    const userId = Encrypt.decode(token)
    const user = await User.find(userId)

    if (!user) return this.forbidden()
    this.currentUser = await User.find(userId)
  }
}
```

This means that any controller extending AuthedController will reject a request that does not have a token present that points to a valid user model when decrypted. Using the `Encrypt` library provided by psychic will simply use bcrypt under the hood, along with the `APP_ENCRYPTION_KEY` that is autogenerated for your development and test environments (for production, we recommend you use whatever assigning and rotating patterns you want for this environment variable, but know that anything you encrypt and store will need to be brought into memory, re-hashed to the new pattern, and then stored again).

Getting back to the files that were just generated for us, we also have:

3. a `UserSerializer`

```ts
import { DreamSerializer, Attribute, DreamColumn } from '@rvohealth/dream'
import User from '../models/User'

export class UserSummarySerializer<
  DataType extends User,
  Passthrough extends object,
> extends DreamSerializer<DataType, Passthrough> {
  @Attribute('string')
  public id: DreamColumn<User, 'id'>
}

export default class UserSerializer<
  DataType extends User,
  Passthrough extends object,
> extends UserSummarySerializer<DataType, Passthrough> {
  @Attribute('string')
  public email: DreamColumn<User, 'email'>

  @Attribute('enum:UserRolesEnum')
  public userRole: DreamColumn<User, 'userRole'>
}
```

Notice that there are two serializer classes exported. One is meant to be used when rendering a list, and the other is meant to be used when showing the record. We can see that the passwordDigest field is present in out serializer, so lets remove that. Typically, you aren't listing or serializing users in your application, so we will likely not be using them, however these are dead useful for rendering anything else in your application that needs rendering.

Psychic comes equipped to intelligently recognize when you are rendering a collection of dreams, and will render the `default` serializer, unless instructed otherwise to do so, like so:

```ts
export default class ApiV1PetsController extends AuthedController {
  public async index() {
    const pets = await Pet.all()
    this.ok(pets, { serializer: 'summary' })
  }
}
```

A migration is also generated for you, which describes the attributes you provided in the generator. Let's add notNull to our email, password, and role columns:

```ts
import { Kysely, sql } from 'kysely'

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export async function up(db: Kysely<any>): Promise<void> {
  await db.schema
    .createType('user_roles_enum')
    .asEnum(['App', 'Admin'])
    .execute()

  await db.schema
    .createTable('users')
    .addColumn('id', 'bigserial', (col) => col.primaryKey())
    .addColumn('email', 'varchar(255)', (col) => col.notNull())
    .addColumn('password_digest', 'varchar(255)', (col) => col.notNull())
    .addColumn('user_role', sql`user_roles_enum`, (col) => col.notNull())
    .addColumn('created_at', 'timestamp', (col) => col.notNull())
    .addColumn('updated_at', 'timestamp', (col) => col.notNull())
    .execute()
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export async function down(db: Kysely<any>): Promise<void> {
  await db.schema.dropTable('users').execute()
  await db.schema.dropType('user_roles_enum').execute()
}
```

Let's run these migrations to get our databases set up and our schemas built. Since this is our first time, we will go ahead and just reset our databases, which will automatically drop them (if they exist) then recreate them, then run migrations on them and do all the necessary introspection to build the schema files for dream and kysely.

```bash
NODE_ENV=test yarn psy db:reset
NODE_ENV=development yarn psy db:reset
```

This will, amongst a few other things, generate the `schema.ts` file, which helps dream and psychic provide a rich type experience for the developer, as well as provide automatic param validation mechanisms, etc...

```ts
// api/src/db/schema.ts

import { CalendarDate } from '@rvohealth/dream'
import { DateTime } from 'luxon'
import { UserRolesEnumValues, IdType, UserRolesEnum } from './sync'

export const schema = {
  users: {
    columns: {
      createdAt: {
        coercedType: {} as DateTime,
        enumType: null,
        enumValues: null,
        dbType: 'timestamp without time zone',
        allowNull: false,
        isArray: false,
      },
      email: {
        coercedType: {} as string | null,
        enumType: null,
        enumValues: null,
        dbType: 'character varying',
        allowNull: true,
        isArray: false,
      },
      id: {
        coercedType: {} as IdType,
        enumType: null,
        enumValues: null,
        dbType: 'bigint',
        allowNull: false,
        isArray: false,
      },
      passwordDigest: {
        coercedType: {} as string | null,
        enumType: null,
        enumValues: null,
        dbType: 'character varying',
        allowNull: true,
        isArray: false,
      },
      updatedAt: {
        coercedType: {} as DateTime,
        enumType: null,
        enumValues: null,
        dbType: 'timestamp without time zone',
        allowNull: false,
        isArray: false,
      },
      userRole: {
        coercedType: {} as UserRolesEnum | null,
        enumType: {} as UserRolesEnum,
        enumValues: UserRolesEnumValues,
        dbType: 'user_roles_enum',
        allowNull: true,
        isArray: false,
      },
    },
    virtualColumns: [],
    associations: {},
  },
} as const
```

A simple factory was generated earlier, as well as a model spec and controller spec, which are both empty (for now). Let's add some specs to fulfull an authentication pattern. we will need a signup pattern, a signin pattern, and some kind of auth check pattern to get us going. For starters, let's create two controller specs, one for our authentication controller, and one to just return a status if the user is logged in.

Let's start with the `AuthController.spec.ts` file:

```ts
// api/spec/unit/controllers/Api/V1/AuthedController.spec.ts

/* eslint-disable @typescript-eslint/no-unsafe-member-access */
import { describe as context } from '@jest/globals'
import { Encrypt, PsychicServer } from '@rvohealth/psychic'
import * as request from 'supertest'
import User from '../../../../../src/app/models/User'
import { UpdateableProperties } from '@rvohealth/dream'
import createUser from '../../../../factories/UserFactory'

const server = new PsychicServer()

describe('ApiV1AuthController', () => {
  beforeEach(async () => {
    await server.boot()
  })

  describe('POST /api/v1/signup', () => {
    function subject(params: UpdateableProperties<User>) {
      return request.agent(server.app).post('/api/v1/signup').send(params)
    }

    it('creates a user', async () => {
      await subject({ email: 'how@yadoin', password: 'password' }).expect(201)
      const user = await User.first()
      expect(user.email).toEqual('how@yadoin')
      expect(await user.checkPassword('password')).toEqual(true)
    })
  })

  describe('POST /api/v1/signin', () => {
    let user: User
    beforeEach(async () => {
      user = await createUser({ email: 'how@yadoin', password: 'password' })
    })

    function subject(email: string, password: string) {
      return request
        .agent(server.app)
        .post('/api/v1/signin')
        .send({ email, password })
    }

    it('signs in a user', async () => {
      const res = await subject('how@yadoin', 'password').expect(200)
      const token = res.body.token as string
      expect(Encrypt.decode(token)).toEqual(user.id)
    })

    context('with invalid credentials', () => {
      it('returns 401', async () => {
        await subject('how@yadoin', 'notpassword').expect(401)
      })
    })
  })

  describe('GET /api/v1/users/me', () => {
    function subject(token: string) {
      return request.agent(server.app).get('/api/v1/users/me').set({ token })
    }

    async function getToken() {
      const res = await request
        .agent(server.app)
        .post('/api/v1/signin')
        .send({ email: 'how@yadoin', password: 'password' })
      return res.body.token as string
    }

    it('returns 204 with an authed user', async () => {
      await createUser({ email: 'how@yadoin', password: 'password' })
      await subject(await getToken()).expect(204)
    })

    it('returns 401 with no authed user', async () => {
      await createUser({ email: 'how@yadoin', password: 'password' })
      await subject('invalidtoken').expect(401)
    })
  })
})
```

and our `UsersController.spec.ts` file:

```ts
// api/spec/unit/controllers/Api/V1/UsersController.spec.ts

/* eslint-disable @typescript-eslint/no-unsafe-member-access */
import { PsychicServer } from '@rvohealth/psychic'
import * as request from 'supertest'
import createUser from '../../../../factories/UserFactory'

const server = new PsychicServer()

describe('ApiV1UsersController', () => {
  beforeEach(async () => {
    await server.boot()
  })

  describe('GET /api/v1/users/me', () => {
    function subject(token: string) {
      return request.agent(server.app).get('/api/v1/users/me').set({ token })
    }

    async function getToken() {
      const res = await request
        .agent(server.app)
        .post('/api/v1/signin')
        .send({ email: 'how@yadoin', password: 'password' })
      return res.body.token as string
    }

    it('returns 204 with an authed user', async () => {
      await createUser({ email: 'how@yadoin', password: 'password' })
      await subject(await getToken()).expect(204)
    })

    it('returns 401 with no authed user', async () => {
      await createUser({ email: 'how@yadoin', password: 'password' })
      await subject('invalidtoken').expect(401)
    })
  })
})
```

Right away upon writing these, we can see that there is some missing behavior and methods on the `User` model. Let's add specs to cover those as well!

```ts
// spec/unit/models/User.spec.ts

import { describe as context } from '@jest/globals'
import { Hash } from '@rvohealth/psychic'
import createUser from '../../factories/UserFactory'

describe('User', () => {
  context('upon saving a password', () => {
    it('hashes the password and stores it in the db', async () => {
      const user = await createUser({
        email: 'how@yadoin',
        password: 'password',
      })
      expect(user.password).toBeUndefined()
      expect(await Hash.check('password', user.passwordDigest)).toEqual(true)
    })
  })

  describe('#checkPassword', () => {
    it('returns true with a valid password', async () => {
      const user = await createUser({
        email: 'how@yadoin',
        password: 'password',
      })
      expect(await user.checkPassword('password')).toEqual(true)
    })

    it('returns false with an invalid password', async () => {
      const user = await createUser({
        email: 'how@yadoin',
        password: 'password',
      })
      expect(await user.checkPassword('passwordz')).toEqual(false)
    })
  })
})
```

Now that we have some failing specs, let's get them passing by adding some implementation. We will start by fulfilling our failing User spec by adding a `Virtual` column called `password` on the `User` model, and then leveraging model hooks to make sure to hash the password before storing it. We will also need to add a `checkPassword` method to verify passwords from our controller.

```ts
// api/src/app/models/User.ts

import { BeforeSave, DreamColumn, Virtual } from '@rvohealth/dream'
import ApplicationModel from './ApplicationModel'
import UserSerializer, {
  UserSummarySerializer,
} from '../../../src/app/serializers/UserSerializer'
import { Hash } from '@rvohealth/psychic'

export default class User extends ApplicationModel {
  public get table() {
    return 'users' as const
  }

  public get serializers() {
    return {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      default: UserSerializer<any, any>,

      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      summary: UserSummarySerializer<any, any>,
    } as const
  }

  public id: DreamColumn<User, 'id'>
  public email: DreamColumn<User, 'email'>
  public passwordDigest: DreamColumn<User, 'passwordDigest'>
  public userRole: DreamColumn<User, 'userRole'>
  public createdAt: DreamColumn<User, 'createdAt'>
  public updatedAt: DreamColumn<User, 'updatedAt'>

  @Virtual()
  public password: string | undefined

  @BeforeSave()
  public async hashPassword() {
    if (this.password) this.passwordDigest = await Hash.gen(this.password)
    this.password = undefined
  }

  public async checkPassword(plaintextPassword: string) {
    return await Hash.check(plaintextPassword, this.passwordDigest)
  }
}
```

now let's run our user specs:

```bash
yarn uspec models/User.spec.ts
```

This should get our specs to go green for the User model, now let's focus on implementation for our controllers. Let's start with the `AuthController`:

```ts
// api/src/app/controllers/api/v1/AuthController.ts

import User from '../../../models/User'
import { Encrypt, PsychicController } from '@rvohealth/psychic'

export default class ApiV1AuthController extends PsychicController {
  public async signup() {
    const user = await User.create(this.paramsFor(User))
    this.created(user.id)
  }

  public async signin() {
    const email = this.castParam('email', 'string')
    const password = this.castParam('password', 'string')
    const user = await User.findBy({ email })
    if (!user) return this.unauthorized()

    const validPassword = await user.checkPassword(password)
    if (!validPassword) return this.unauthorized()

    const token = Encrypt.sign(user.id as string)
    this.ok({ token })
  }
}
```

and for our `Users` controller:

```ts
// api/src/app/controllers/api/v1/UsersController.ts

import AuthedController from '../../AuthedController'

export default class ApiV1UsersController extends AuthedController {
  public async me() {
    if (!this.currentUser) return this.unauthorized()
    this.noContent()
  }
}
```

now we can see all specs going green:

```bash
yarn uspec
```
