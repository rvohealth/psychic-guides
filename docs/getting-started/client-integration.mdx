---
sidebar_position: 3
---

import RightSidebarItem from '@site/src/components/ui/right-sidebar-item'

# client integration

Now that we have this, we can start our dev server at port 7777

```bash
psy dev
```

Of course, you will need to connect a front end to this to provide an interface for your app. If you have chosen to build your psychic app with a client integration (like react or vue), then one will have been provisioned automatically for you, and can be located in the `client` folder at the root of your app. To launch this, you can run `CLIENT=1 yarn dev`, which will automatically run the `yarn client` command to sidelaunch your client.

```bash
CLIENT=1 yarn dev
```

Though psychic and dream don't force a particular client upon you per-say, they will provide nice helpers to sync api routes and serializer schemas over to your frontend, so that you don't have to manually re-create all your backend interfaces, or manually keep them up to date when you change the db schema using migrations.

To utilize this integration, you can run the following in the console:

```bash
yarn psy sync:client
```

This will sync client files over to your frontend client for you, allowing you to make use of them in your app without much effort.

If you are following along with the [authentication](/docs/getting-started/authenticating) tutorial, then when you generated your `User` model, it will have also generated a client api file at `client/src/api/users.ts`. This api module is meant to carry all of the routes related to the user, but it did not guess correctly at what methods would be needed (since users are always a bit of an odd case in resource paradigms). Let's open that file and change it to the routes that exist in our system:

```ts
// client/src/api/users.ts

import { apiCall } from './common'
import { User } from './schema'

export default class UsersAPI {
  public static create(body: Partial<User>) {
    return apiCall('api.v1.signup.POST').send({ body })
  }

  public static signin(body: { email: string; password: string }) {
    return apiCall('api.v1.signin.POST').send({ body })
  }

  public static me() {
    return apiCall('api.v1.users.me.GET').send()
  }
}
```

Let's get some feature specs written to cover our implementation:

```ts
// api/spec/features/visitor/signs-up.spec.ts

import User from '../../../src/app/models/User'
import clickButton from '../helpers/clickButton'
import expectContent from '../helpers/expectContent'
import fillInput from '../helpers/fillInput'
import visit from '../helpers/visit'

describe('visitor visits the signup page', () => {
  it('allows visitor to fill sign up for a new account and then log in with the same credentials', async () => {
    await visit('/signup')
    await fillInput('#email', 'hello@world')
    await fillInput('#password', 'mypassword')
    await clickButton('sign up')

    await expectContent('Log in')
    await fillInput('#email', 'hello@world')
    await fillInput('#password', 'mypassword')
    await clickButton('log in')

    await expectContent('DASHBOARD')

    const user = await User.last()
    expect(user.email).toEqual('hello@world')
    expect(await user.checkPassword('mypassword')).toEqual(true)
  })
})
```

Running feature specs, we will see failures, which we expect since we have not implemented anything yet.

```bash
yarn fspec api/spec/features/visitor/signs-up.spec.ts
```

It would be good to also have specs to cover unhappy paths for this, but for brevity I will move on. First, let's add some packages we will need on our react frontend

```bash
yarn --cwd=../client add react-router-dom react-redux @reduxjs/toolkit
```

We want a place to be able store our auth token that is outside the bindings of our component layer. To do that, let's create an app store. Feel free to call it whatever you want, I am just calling it app to keep things generic. Another name that might make sense is `auth`, but feel free to namespace however you want. We will only be using it to store the user's auth token upon authenticating.

```ts
// src/stores/app.ts

import { createSlice } from '@reduxjs/toolkit'
import type { PayloadAction } from '@reduxjs/toolkit'

export interface AppStore {
  authed: boolean
}

const initialState: AppStore = {
  authed: false,
}

export const appSlice = createSlice({
  name: 'app',
  initialState,
  reducers: {
    setAuthed: (state, action: PayloadAction<boolean>) => {
      state.authed = action.payload
    },
  },
})

export const { setAuthed } = appSlice.actions
export default appSlice.reducer
```

And let's get that new app store imported into our store index:

```ts
import { configureStore } from '@reduxjs/toolkit'
import appSlice from './app'

export const store = configureStore({
  reducer: {
    app: appSlice,
  },
})

export type RootState = ReturnType<typeof store.getState>
export type AppDispatch = typeof store.dispatch
```

We will also need a hooks file to provide typing to redux, like so:

```ts
// client/src/stores/hooks.ts

import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux'
import type { RootState, AppDispatch } from '.'

// Use throughout your app instead of plain `useDispatch` and `useSelector`
export const useAppDispatch = () => useDispatch<AppDispatch>()
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector
```

Let's also create three different pages to import into our app:

1. A Signup page

```ts
// client/src/pages/Signup.tsx

import { useState } from 'react'
import UsersAPI from '../api/users'
import { useNavigate } from 'react-router-dom'
import routes from '../config/routes'

export default function SignupPage() {
  const navigate = useNavigate()
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')

  return (
    <div>
      <label htmlFor="email">email</label>
      <input
        name="email"
        type="text"
        id="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
      />

      <label htmlFor="password">password</label>
      <input
        name="password"
        type="password"
        id="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
      />

      <button
        onClick={async () => {
          await UsersAPI.create({ email, password })
          navigate(routes.app.login)
        }}
      >
        sign up
      </button>
    </div>
  )
}
```

2. A Login page

```ts
// client/src/pages/Login.tsx

import { useState } from 'react'
import UsersAPI from '../api/users'

export default function LoginPage() {
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')

  return (
    <div>
      <h1>Log in</h1>

      <label htmlFor="email">email</label>
      <input
        name="email"
        type="text"
        id="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
      />

      <label htmlFor="password">password</label>
      <input
        name="password"
        type="password"
        id="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
      />

      <button
        onClick={async () => {
          await UsersAPI.signin({ email, password })
          // use window.location to trigger a full page reload here
          window.location.pathname = '/'
        }}
      >
        log in
      </button>
    </div>
  )
}
```

3. A Dashboard page

```ts
// client/src/pages/Dashboard.tsx

export default function DashboardPage() {
  return <div>DASHBOARD</div>
}
```

Let's add react router and redux providers to our app root. Open `main.tsx` and add the `BrowserRouter` provided by `react-router-dom` to your JSX, as well as the `Provider` from `react-redux` like so:

```ts
// client/src/main.tsx

import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
import './index.css'
import { BrowserRouter as Router } from 'react-router-dom'
import { store } from './stores/index'
import { Provider } from 'react-redux'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <Provider store={store}>
      <Router>
        <App />
      </Router>
    </Provider>
  </React.StrictMode>
)
```

With these pages ready to go, and redux and react router correctly hooked up, we can import our new pages into the `App.tsx` file, which we have been patiently avoiding. We will use a basic auth check useEffect call at the root of App.tsx, and if that returns with a 204, we will dispatch `setAuthed(true)` to inform our redux store that we are authenticated. This will cause us to render our `AuthedApp` instead of our `UnauthedApp`.

```ts
// client/src/App.tsx

import { Navigate, Route, Routes } from 'react-router-dom'
import './App.css'
import routes from './config/routes'
import SignupPage from './pages/Signup'
import LoginPage from './pages/Login'
import DashboardPage from './pages/Dashboard'
import { useAppDispatch, useAppSelector } from './stores/hooks'
import { useEffect } from 'react'
import UsersAPI from './api/users'
import { setAuthed } from './stores/app'

function App() {
  const dispatch = useAppDispatch()
  const authed = useAppSelector((state) => state.app.authed)

  useEffect(() => {
    async function authCheck() {
      try {
        await UsersAPI.me()
        dispatch(setAuthed(true))
      } catch (_) {
        // no worries if they are not logged in.
      }
    }
    void authCheck()
  }, [])

  if (authed) return <AuthedApp />
  return <UnauthedApp />
}

function AuthedApp() {
  return (
    <Routes>
      <Route
        path={routes.app.signup}
        element={<Navigate to={routes.app.home} />}
      />
      <Route
        path={routes.app.login}
        element={<Navigate to={routes.app.home} />}
      />
      <Route path={routes.app.home} element={<DashboardPage />} />
    </Routes>
  )
}

function UnauthedApp() {
  return (
    <Routes>
      <Route path={routes.app.signup} element={<SignupPage />} />
      <Route path={routes.app.login} element={<LoginPage />} />
      <Route
        path={routes.app.home}
        element={<Navigate to={routes.app.login} />}
      />
    </Routes>
  )
}

export default App
```

With our code in place, we can now run our feature specs again to verify that it is passing:

```bash
yarn fspec
```

If you'd like to see more debug information, you can also run with:

```bash
DEBUG=1 yarn fspec
```

Additionally, to run the fspec in a real browser (firefox by default), you can run:

```bash
BROWSER=1 yarn fspec
```
